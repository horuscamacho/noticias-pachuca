# üêõ BUG: Generaci√≥n de Im√°genes con IA - An√°lisis Real del C√≥digo

**Fecha:** 13 Octubre 2025
**Autor:** Jarvis (Claude Code)
**Estado:** An√°lisis completo - Esperando luz verde para implementaci√≥n

---

## üìã TABLA DE CONTENIDOS
1. [QU√â TENEMOS (Estado Actual del C√≥digo)](#1-qu√©-tenemos-estado-actual-del-c√≥digo)
2. [QU√â QUEREMOS (Objetivos del Fix)](#2-qu√©-queremos-objetivos-del-fix)
3. [PROBLEMAS IDENTIFICADOS](#3-problemas-identificados)
4. [PLAN DE IMPLEMENTACI√ìN](#4-plan-de-implementaci√≥n)
5. [REGLAS DE IMPLEMENTACI√ìN](#5-reglas-de-implementaci√≥n)

---

## 1. QU√â TENEMOS (Estado Actual del C√≥digo)

### 1.1 BACKEND - API (NestJS)

#### ‚úÖ LO QUE FUNCIONA:

**1. OpenAI Adapter** (`openai.adapter.ts`)
- ‚úÖ L√≠neas 406-468: M√©todo `generateImage()` funcional usando `/images/generations`
- ‚úÖ L√≠neas 475-550: M√©todo `editImage()` EXISTE y est√° bien implementado usando `/images/edits`
- ‚úÖ Costo calculado correctamente (l√≠nea 672-689)
- ‚úÖ Manejo de FormData para multipart (l√≠nea 485-510)
- ‚úÖ Conversi√≥n de Buffer a Blob correcta (l√≠nea 488-489)

**2. Image Generation Processor** (`image-generation.processor.ts`)
- ‚úÖ L√≠nea 38: Emite evento `image-generation.started` v√≠a EventEmitter2
- ‚úÖ L√≠nea 46: Emite progreso usando `emitProgress()` privado
- ‚úÖ L√≠nea 173: Emite evento `image-generation.completed`
- ‚úÖ L√≠nea 193: Emite evento `image-generation.failed`
- ‚úÖ L√≠nea 230: M√©todo `emitProgress()` con estructura correcta
- ‚úÖ Post-processing completo: 12 variantes (4 tama√±os √ó 3 formatos)
- ‚úÖ Upload a S3 autom√°tico

**3. Image Generation Service** (`image-generation.service.ts`)
- ‚úÖ L√≠nea 152-153: Campos `sourceImageId` y `sourceImageUrl` se guardan en BD
- ‚úÖ L√≠nea 169-181: Job data incluye todos los campos necesarios
- ‚úÖ An√°lisis de contenido funcional (ContentAnalyzerService)
- ‚úÖ Prompt editorial profesional (EditorialPromptService)

**4. Image Generation Notifier** (`image-generation-notifier.service.ts`)
- ‚úÖ L√≠nea 43: @OnEvent escucha `IMAGE_GENERATION_EVENTS.STARTED`
- ‚úÖ L√≠nea 73: @OnEvent escucha `IMAGE_GENERATION_EVENTS.PROGRESS`
- ‚úÖ L√≠nea 98: @OnEvent escucha `IMAGE_GENERATION_EVENTS.COMPLETED`
- ‚úÖ L√≠nea 123: @OnEvent escucha `IMAGE_GENERATION_EVENTS.FAILED`
- ‚úÖ L√≠nea 48: Usa `socketGateway.sendToUser()` correctamente
- ‚úÖ Eventos con prefijo `image-generation:*` (l√≠nea 50, 80, 105, 130)

**5. Socket Gateway** (`socket.gateway.ts`)
- ‚úÖ L√≠nea 356: M√©todo p√∫blico `sendToUser()` funcional
- ‚úÖ L√≠nea 102: Join a room `user_${userId}` autom√°tico
- ‚úÖ Redis Adapter configurado (l√≠nea 49-60)
- ‚úÖ Autenticaci√≥n JWT funcional

**6. Events Definitions** (`image-generation.events.ts`)
- ‚úÖ Todos los eventos tipados correctamente
- ‚úÖ Interfaces exportadas: Started, Progress, Completed, Failed

#### ‚ùå LO QUE NO FUNCIONA:

**1. NO se usa `editImage()` cuando hay imagen de referencia**
- ‚ùå L√≠nea 61 de `processor.ts`: SIEMPRE llama `provider.generateImage()`
- ‚ùå NO verifica si hay `sourceImageId` o `sourceImageUrl` en job.data
- ‚ùå Campo `sourceImageId` existe en schema (l√≠nea 152 service) pero se ignora
- ‚ùå Campo `sourceImageUrl` existe en schema (l√≠nea 153 service) pero se ignora

**2. Service NO descarga imagen de referencia**
- ‚ùå `generateNewsImage()` NO descarga imagen si hay `sourceImageId`
- ‚ùå NO pasa buffer de imagen al job data
- ‚ùå Job data NO incluye campo para `referenceImageBuffer`

---

### 1.2 MOBILE - App (React Native + Expo)

#### ‚úÖ LO QUE FUNCIONA:

**1. Socket Types** (`socket.types.ts`)
- ‚úÖ L√≠nea 107-137: Interfaces de eventos YA EXISTEN:
  - `ImageGenerationStartedEvent`
  - `ImageGenerationProgressEvent`
  - `ImageGenerationCompletedEvent`
  - `ImageGenerationFailedEvent`
- ‚úÖ L√≠nea 235-238: Eventos en `SocketEventMap` YA DEFINIDOS:
  - `image-generation:started`
  - `image-generation:progress`
  - `image-generation:completed`
  - `image-generation:failed`

**2. Socket Service** (`SocketService.ts`)
- ‚úÖ Singleton funcional (l√≠nea 19-24)
- ‚úÖ Conexi√≥n autom√°tica con JWT (l√≠nea 42-43)
- ‚úÖ Headers correctos (`x-platform: mobile`, `x-device-id`)
- ‚úÖ M√©todo `emit()` tipado (l√≠nea 154)

**3. useContentGenerationSocket Hook** (`useContentGenerationSocket.ts`)
- ‚úÖ **PATR√ìN PERFECTO PARA SEGUIR**:
  - L√≠nea 23: Set de `processingIds`
  - L√≠nea 26-41: M√©todos `addProcessingId()` y `removeProcessingId()`
  - L√≠nea 65: `SocketService.getInstance(queryClient)`
  - L√≠nea 77-81: Handler con logging
  - L√≠nea 89-99: Invalidar queries de React Query
  - L√≠nea 114-116: Registrar listeners con `socket.on()`
  - L√≠nea 121-126: Cleanup con `socket.off()`
  - L√≠nea 131-133: Return `{ processingIds, isProcessing }`

**4. Image Generation API** (`imageGenerationApi.ts`)
- ‚úÖ L√≠nea 39: Usa `ApiClient.getRawClient()` correctamente
- ‚úÖ L√≠nea 40: Mappers bidireccionales funcionan
- ‚úÖ L√≠nea 47: Timeout de 120s para requests largos
- ‚úÖ Todos los endpoints funcionan (getById, getGenerations, getJobStatus, etc.)

**5. useImageGeneration Hook** (`useImageGeneration.ts`)
- ‚úÖ Mutation hook funcional
- ‚úÖ L√≠nea 34: Invalidate queries despu√©s de mutate
- ‚úÖ Error handling correcto

#### ‚ùå LO QUE NO FUNCIONA:

**1. NO existe hook `useImageGenerationSocket`**
- ‚ùå NO hay equivalente a `useContentGenerationSocket` para im√°genes
- ‚ùå Pantallas NO escuchan eventos `image-generation:*`
- ‚ùå NO hay estado de progreso en tiempo real

**2. SocketService NO expone socket**
- ‚ùå L√≠nea 11 de `SocketService.ts`: `socket` es `private`
- ‚ùå Para usar `socket.on()` necesitamos acceso p√∫blico
- ‚ùå Necesitamos agregar getter `get socket()` p√∫blico

**3. NO hay pantallas identificadas**
- ‚ùå Directorio `features/image-bank/screens` no existe
- ‚ùå Necesito encontrar d√≥nde est√° la UI de generaci√≥n de im√°genes
- ‚ùå No s√© d√≥nde integrar el hook cuando est√© listo

---

## 2. QU√â QUEREMOS (Objetivos del Fix)

### 2.1 BACKEND

**OBJETIVO 1: Usar imagen de referencia cuando est√© disponible**
- ‚úÖ Si `sourceImageId` presente ‚Üí descargar de ImageBank
- ‚úÖ Si `sourceImageUrl` presente ‚Üí descargar de URL
- ‚úÖ Convertir a PNG con alpha channel (requerido por OpenAI)
- ‚úÖ Pasar buffer al processor
- ‚úÖ Processor usa `editImage()` en vez de `generateImage()`

**OBJETIVO 2: Eventos socket ya funcionan**
- ‚úÖ Notifier service YA funciona correctamente
- ‚úÖ SocketGateway YA reenv√≠a eventos
- ‚úÖ NO necesitamos modificar esta parte
- ‚úÖ Solo agregar logs si es necesario

---

### 2.2 MOBILE

**OBJETIVO 1: Crear hook para progreso en tiempo real**
- ‚úÖ `useImageGenerationSocket` siguiendo patr√≥n de `useContentGenerationSocket`
- ‚úÖ Escuchar eventos `image-generation:*`
- ‚úÖ Mantener Set de `processingGenerations`
- ‚úÖ Invalidar queries autom√°ticamente

**OBJETIVO 2: Exponer socket en SocketService**
- ‚úÖ Cambiar `private socket` a getter p√∫blico
- ‚úÖ Mantener encapsulaci√≥n pero permitir acceso a listeners

**OBJETIVO 3: Integrar en UI**
- ‚úÖ Encontrar pantallas de generaci√≥n de im√°genes
- ‚úÖ Integrar hook con loading states
- ‚úÖ Mostrar progreso en tiempo real
- ‚úÖ Manejar errores visualmente

---

## 3. PROBLEMAS IDENTIFICADOS

### Problema 1: Backend ignora imagen de referencia

**Ubicaci√≥n:** `image-generation.processor.ts:61`

**C√≥digo actual:**
```typescript
const result = await provider.generateImage({
  prompt,
  quality,
  size,
  outputFormat: 'png',
});
```

**Por qu√© falla:**
- Siempre usa `/images/generations` (NO acepta im√°genes)
- Campos `sourceImageId` y `sourceImageUrl` del job.data NO se usan
- Service NO descarga la imagen antes de encolar job

**Soluci√≥n:**
1. Service debe descargar imagen si hay `sourceImageId`/`sourceImageUrl`
2. Convertir a Buffer y validar formato PNG
3. Pasar buffer en job data
4. Processor debe detectar si hay buffer y usar `editImage()`

---

### Problema 2: SocketService no expone socket

**Ubicaci√≥n:** `SocketService.ts:11`

**C√≥digo actual:**
```typescript
private socket: Socket | null = null
```

**Por qu√© falla:**
- Hooks necesitan hacer `socket.on()` para registrar listeners
- Socket es privado, no accesible desde fuera
- No podemos seguir el patr√≥n de `useContentGenerationSocket`

**Soluci√≥n:**
Agregar getter p√∫blico:
```typescript
get socket(): Socket | null {
  return this.socket
}
```

---

### Problema 3: NO hay hook para eventos de image generation

**Ubicaci√≥n:** Falta crear archivo

**Por qu√© falla:**
- Eventos del backend llegan correctamente
- Mobile NO tiene nadie escuchando
- Pantallas NO se actualizan en tiempo real
- Puede causar crashes si llega evento sin handler

**Soluci√≥n:**
Crear `useImageGenerationSocket.ts` siguiendo patr√≥n exacto de `useContentGenerationSocket.ts`

---

## 4. PLAN DE IMPLEMENTACI√ìN

---

### FASE 1: Backend - Soportar Imagen de Referencia (3-4 horas)

**Archivos a modificar:**
1. `openai.adapter.ts` - Agregar m√©todo wrapper
2. `image-generation.service.ts` - Descargar imagen
3. `image-generation-queue.service.ts` - Agregar campo buffer
4. `image-generation.processor.ts` - Usar editImage cuando corresponda

#### Micro-tareas:

##### 1.1 Agregar campo `referenceImageBuffer` a job data

- [ ] **1.1.1** Modificar interface `ImageGenerationJobData` en `image-generation-queue.service.ts`
  ```typescript
  export interface ImageGenerationJobData {
    // ... campos existentes
    referenceImageBuffer?: Buffer; // NUEVO
  }
  ```

##### 1.2 Service: Descargar imagen de referencia

- [ ] **1.2.1** Agregar m√©todo `downloadReferenceImage()` en `image-generation.service.ts`
  - Si `sourceImageId` ‚Üí buscar en ImageBank
  - Si `sourceImageUrl` ‚Üí fetch de URL
  - Validar que sea imagen v√°lida
  - Convertir a PNG con sharp si no lo es
  - Retornar Buffer

- [ ] **1.2.2** Modificar `generateNewsImage()` para usar nuevo m√©todo
  - L√≠nea ~169: Antes de encolar job, llamar a `downloadReferenceImage()`
  - Si hay buffer, incluirlo en job data
  - Logging claro: "Using reference image from ImageBank/URL"

##### 1.3 Processor: Detectar y usar editImage

- [ ] **1.3.1** Modificar `handleImageGeneration()` en `image-generation.processor.ts`
  - L√≠nea ~61: Extraer `referenceImageBuffer` de job.data
  - Si existe buffer:
    ```typescript
    const result = await provider.editImage({
      imageBuffer: referenceImageBuffer,
      prompt,
      size,
    });
    ```
  - Si NO existe buffer (caso actual):
    ```typescript
    const result = await provider.generateImage({
      prompt,
      quality,
      size,
      outputFormat: 'png',
    });
    ```
  - Logging: "Using /images/edits" vs "Using /images/generations"

##### Build y Test

- [ ] **1.4** Build de API
  ```bash
  cd packages/api-nueva
  yarn build
  ```

- [ ] **1.5** Test manual con Postman
  - Request SIN `sourceImageId` ‚Üí debe usar /generations
  - Request CON `sourceImageId` v√°lido ‚Üí debe usar /edits
  - Verificar logs muestran endpoint correcto

**Criterio de √©xito:**
- ‚úÖ Build compila sin errores
- ‚úÖ Logs dicen "Using /images/edits" cuando hay sourceImageId
- ‚úÖ Logs dicen "Using /images/generations" cuando NO hay
- ‚úÖ Imagen generada usa referencia como inspiraci√≥n (visual test)

**Tiempo estimado:** 3-4 horas

---

### FASE 2: Mobile - Exponer Socket en SocketService (15 minutos)

**Archivo a modificar:**
1. `SocketService.ts`

#### Micro-tareas:

- [ ] **2.1** Agregar getter p√∫blico para socket
  - L√≠nea ~200 (despu√©s de `get connectionState`):
  ```typescript
  /**
   * Get socket instance for registering custom listeners
   * Used by hooks like useImageGenerationSocket
   */
  get socket(): Socket | null {
    return this.socket
  }
  ```

**Criterio de √©xito:**
- ‚úÖ TypeScript compila sin errores
- ‚úÖ `socketService.socket` es accesible desde hooks

**Tiempo estimado:** 15 minutos

---

### FASE 3: Mobile - Crear Hook useImageGenerationSocket (2 horas)

**Archivo a crear:**
1. `useImageGenerationSocket.ts`

#### Micro-tareas:

##### 3.1 Crear archivo y estructura base

- [ ] **3.1.1** Crear `packages/mobile-expo/src/hooks/useImageGenerationSocket.ts`
- [ ] **3.1.2** Copiar estructura completa de `useContentGenerationSocket.ts`
- [ ] **3.1.3** Renombrar:
  - `ContentGenerationSocketOptions` ‚Üí `ImageGenerationSocketOptions`
  - `processingIds` se mantiene igual
  - Eventos: `image-generation:started|progress|completed|failed`

##### 3.2 Implementar callbacks

- [ ] **3.2.1** Tipos de opciones:
  ```typescript
  interface ImageGenerationSocketOptions {
    onGenerationStarted?: (data: SocketAPI.ImageGenerationStartedEvent) => void;
    onGenerationProgress?: (data: SocketAPI.ImageGenerationProgressEvent) => void;
    onGenerationCompleted?: (data: SocketAPI.ImageGenerationCompletedEvent) => void;
    onGenerationFailed?: (data: SocketAPI.ImageGenerationFailedEvent) => void;
  }
  ```

##### 3.3 Implementar handlers

- [ ] **3.3.1** Handler `handleGenerationStarted`:
  - Agregar `generationId` a `processingIds`
  - Llamar callback opcional
  - Logging: `üì® [Socket Event] image-generation:started`

- [ ] **3.3.2** Handler `handleGenerationProgress`:
  - Solo logging (NO agregar/remover de Set)
  - Llamar callback opcional
  - Logging: `üìä [Socket Event] Progress: ${progress}%`

- [ ] **3.3.3** Handler `handleGenerationCompleted`:
  - Remover `generationId` de `processingIds`
  - Invalidar queries:
    ```typescript
    queryClient.invalidateQueries({ queryKey: imageGenerationKeys.lists() });
    queryClient.invalidateQueries({ queryKey: imageGenerationKeys.detail(generationId) });
    queryClient.invalidateQueries({ queryKey: imageGenerationKeys.stats() });
    ```
  - Llamar callback opcional
  - Logging: `‚úÖ [Socket Event] image-generation:completed`

- [ ] **3.3.4** Handler `handleGenerationFailed`:
  - Remover `generationId` de `processingIds`
  - Invalidar queries de lists
  - Llamar callback opcional
  - Logging: `‚ùå [Socket Event] image-generation:failed`

##### 3.4 Registrar y limpiar listeners

- [ ] **3.4.1** useEffect con dependencies correctas:
  ```typescript
  useEffect(() => {
    const socketService = SocketService.getInstance(queryClient);
    const socket = socketService.socket;

    if (!socket) {
      console.warn('‚ö†Ô∏è [useImageGenerationSocket] Socket not available');
      return;
    }

    socket.on('image-generation:started', handleGenerationStarted);
    socket.on('image-generation:progress', handleGenerationProgress);
    socket.on('image-generation:completed', handleGenerationCompleted);
    socket.on('image-generation:failed', handleGenerationFailed);

    return () => {
      socket.off('image-generation:started', handleGenerationStarted);
      socket.off('image-generation:progress', handleGenerationProgress);
      socket.off('image-generation:completed', handleGenerationCompleted);
      socket.off('image-generation:failed', handleGenerationFailed);
    };
  }, [queryClient, addProcessingId, removeProcessingId, ...callbacks]);
  ```

##### 3.5 Return values

- [ ] **3.5.1** Return objeto:
  ```typescript
  return {
    processingIds,
    isProcessing: (id: string) => processingIds.has(id)
  };
  ```

**Criterio de √©xito:**
- ‚úÖ TypeScript compila sin errores
- ‚úÖ Hook se puede importar sin problemas
- ‚úÖ NO hay warnings de useEffect dependencies
- ‚úÖ Logging muestra eventos llegando

**Tiempo estimado:** 2 horas

---

### FASE 4: Mobile - Integrar Hook en UI (2-3 horas)

**Archivos a identificar y modificar:**
- Pantallas de generaci√≥n de im√°genes (por encontrar)

#### Micro-tareas:

##### 4.1 Encontrar pantallas

- [ ] **4.1.1** Buscar archivos:
  ```bash
  find packages/mobile-expo/src -name "*[Ii]mage*[Gg]enerat*" -o -name "*[Aa]i*[Ii]mage*"
  ```

- [ ] **4.1.2** Identificar:
  - Pantalla de generaci√≥n (formulario)
  - Pantalla de detalle de generaci√≥n
  - Lista de generaciones

##### 4.2 Integrar en pantalla de detalle

- [ ] **4.2.1** Importar hook:
  ```typescript
  import { useImageGenerationSocket } from '@/src/hooks/useImageGenerationSocket';
  ```

- [ ] **4.2.2** Usar hook con callbacks:
  ```typescript
  const { isProcessing } = useImageGenerationSocket({
    onGenerationCompleted: (data) => {
      refetch(); // Refetch generation detail
    },
    onGenerationFailed: (data) => {
      Alert.alert('Error', data.error);
    }
  });
  ```

- [ ] **4.2.3** Mostrar loading state:
  ```typescript
  {isProcessing(generationId) && (
    <ActivityIndicator />
  )}
  ```

##### 4.3 Integrar en lista (opcional)

- [ ] **4.3.1** Mostrar badge "Procesando" en items siendo generados
- [ ] **4.3.2** Actualizar autom√°ticamente cuando complete

**Criterio de √©xito:**
- ‚úÖ Pantalla compila sin errores
- ‚úÖ Loading se muestra cuando genera
- ‚úÖ Al completar, se actualiza autom√°ticamente
- ‚úÖ Al fallar, se muestra error
- ‚úÖ NO hay crashes

**Tiempo estimado:** 2-3 horas

---

### FASE 5: Testing Manual Completo (2-3 horas)

#### Micro-tareas:

##### 5.1 Test Backend

- [ ] **5.1.1** Levantar servicios:
  ```bash
  docker-compose up -d
  cd packages/api-nueva && yarn start:dev
  ```

- [ ] **5.1.2** Test con Postman:
  - POST /image-generation/generate SIN `sourceImageId`
  - Verificar logs: "Using /images/generations"
  - POST /image-generation/generate CON `sourceImageId` v√°lido
  - Verificar logs: "Using /images/edits"
  - Verificar logs de notifier: "Sending started/progress/completed"

##### 5.2 Test Mobile

- [ ] **5.2.1** Configurar mobile para local:
  - Apuntar a `http://localhost:4000/api`
  - Verificar socket conecta

- [ ] **5.2.2** Test flujo completo:
  - Generar imagen SIN referencia
  - Verificar progreso en tiempo real
  - Verificar imagen se muestra al completar
  - Generar imagen CON referencia (desde imagen del banco)
  - Verificar usa referencia como inspiraci√≥n
  - Verificar progreso en tiempo real

##### 5.3 Test casos edge

- [ ] **5.3.1** Generar y cerrar app inmediatamente
- [ ] **5.3.2** Generar y salir de pantalla
- [ ] **5.3.3** Generar m√∫ltiples im√°genes simult√°neas
- [ ] **5.3.4** Simular fallo de red durante generaci√≥n

**Criterio de √©xito:**
- ‚úÖ TODOS los casos pasan sin crashes
- ‚úÖ Progreso se muestra correctamente
- ‚úÖ Im√°genes con referencia usan la inspiraci√≥n
- ‚úÖ Eventos socket NO causan crashes
- ‚úÖ Performance aceptable (< 30s total)

**Tiempo estimado:** 2-3 horas

---

## 5. REGLAS DE IMPLEMENTACI√ìN

### 5.1 C√≥digo

1. **NO usar `any`**
   - Todos los tipos expl√≠citos
   - Usar `unknown` si realmente no se conoce
   - Type guards antes de usar

2. **NO usar `forwardRef`**
   - Backend YA usa EventEmitter2 correctamente
   - NO tocar esta arquitectura
   - Mobile usa hooks est√°ndar

3. **Seguir patr√≥n mobile**
   - `ApiClient.getRawClient()`
   - Mappers bidireccionales
   - Namespaces API/App separados

4. **Logging consistente**
   - Backend: `this.logger.log/error/warn`
   - Mobile: `console.log` con prefijo `[HookName]`
   - Formato: `"üî• [ServiceName] Mensaje"`

5. **Error handling exhaustivo**
   - Try-catch en todos los puntos cr√≠ticos
   - Errores claros y legibles
   - NO dejar que un error rompa todo

6. **TypeScript estricto**
   - `strict: true` debe pasar
   - NO usar `@ts-ignore`
   - Preferir interfaces sobre types

### 5.2 Testing

1. **Solo testing manual** (por ahora)
   - Documentar casos ejecutados
   - Validar cada micro-tarea
   - NO testing unitario en esta fase

2. **Regression testing**
   - Despu√©s de cada fase, verificar funcionalidad anterior
   - NO introducir bugs nuevos

### 5.3 Git

1. **Commits peque√±os**
   - Un commit por micro-tarea
   - Formato: `feat(image-gen): descripci√≥n`
   - NO commits gigantes

2. **Branch dedicado**
   - `fix/image-generation-reference-images`
   - NO pushear a main hasta completar

### 5.4 Builds

1. **Build despu√©s de cada fase backend**
   - Verificar compila sin errores
   - Verificar arranca correctamente
   - Logs sin errores

2. **NO builds innecesarios**
   - Si solo cambia mobile, NO rebuild API

---

## üìä TIEMPO TOTAL ESTIMADO

| Fase | Descripci√≥n | Tiempo |
|------|-------------|--------|
| FASE 1 | Backend - Soporte imagen referencia | 3-4h |
| FASE 2 | Mobile - Exponer socket | 15min |
| FASE 3 | Mobile - Hook socket | 2h |
| FASE 4 | Mobile - Integrar UI | 2-3h |
| FASE 5 | Testing manual | 2-3h |
| **TOTAL** | | **10-12h** |

**Distribuci√≥n recomendada:**
- **D√≠a 1:** FASE 1 completa (3-4h)
- **D√≠a 2:** FASE 2 + FASE 3 (2-3h)
- **D√≠a 3:** FASE 4 + FASE 5 (4-6h)

---

## ‚úÖ CHECKLIST FINAL

- [ ] FASE 1: Backend soporta imagen de referencia
- [ ] FASE 2: SocketService expone socket
- [ ] FASE 3: Hook useImageGenerationSocket creado
- [ ] FASE 4: Hook integrado en UI
- [ ] FASE 5: Testing manual completo
- [ ] Build de API funciona
- [ ] Mobile compila sin errores
- [ ] NO hay crashes
- [ ] Documentaci√≥n actualizada
- [ ] Branch listo para merge

---

**FIN DEL DOCUMENTO**

---

*Este documento est√° basado en an√°lisis REAL del c√≥digo. NO mover c√≥digo hasta recibir luz verde de Coyotito.*
